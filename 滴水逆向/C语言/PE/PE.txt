
宏定义说明：

一、无参数的宏定义的一般形式为：#define  标识符   字符序列

1、只作字符序列的的替换工作，不做任何语法的检查
2、如果宏定义不当，错误要到预处理之后的编译阶段才能发现

二、带参数宏定义：#define  标识符（参数表）字符序列

 #define  MAX （A，B）  ( (A)>(B) ? (A) : (B)

    注意：
1、宏名称标识符与左括号之间不允许由空白符，应紧接在一起
2、宏与函数的区别：函数分配额外的堆栈空间，而宏只是替换、
3、为了避免出错，宏定义中给形参加上括号
4、末尾不需要分号
5、define可以替代多行的代码，记得后买你加 \
 
   #define  MALLOC（n，type）\
			((type*)malloc(n)*sizeof（type))

malloc 注意事项

 1.使用sizeof(类型）*n 来申请内存大小
 2.malloc返回类型为void*类型  需要强转
 3.申请完内存一定要判断是否申请成功
 4.初始化
 5.使用完清空堆区
 6.指针值设为NULL


重点：

PE文件的第一个部分是IMAGE_DOS_HEADER，大小为64B，这里面有两个重要的数据成员。
第一个为e_magic，这个必须为MZ，即0x5A4D。当然，0x5A4D这是典型的小端格式（Little Endian）；
另一个重要的数据成员是最后一个成员e_lfanew，这个成员的值为IMAGE_NT_HEADERS的偏移

在一个有效的 PE 文件里，Signature 字段被设置为00004550h, ASCII 码字符是“PE00”。标志这 PE 文件头的开始。
“PE00” 字符串是 PE 文件头的开始，DOS 头部的 e_lfanew 字段正是指向这里。


联合体：

 1、联合体的成员是共享内存空间的
 2、联合体的内存空间大小是联合体成员中对内存空间大小要求最大的空间大小
 3、联合体最多只有一个成员有效
		

PE加载的过程：

1、根据Sizeoflmage的大小，开辟一块缓冲区 imageBuffer（文件在内存中的形式）
2、根据SizeofHerder的大小，将头信息从FileBuffer（文件在硬盘上的形式）拷贝到lmageBuffer
3、根据节表中的信息循环进FileBuffer中的节拷贝到lmageBuffer中


空白区添加代码：

call  对应的硬编码为 E8 
jmp 对应的硬编码为 E9

算法：  

x：硬编码
真正要跳转的地址 是ImageBuffer中的地址，注意文件对齐

  真正要跳转的地址 = E8这条指令的下一行地址 +  x        
  X = 真正要跳转的地址 - E8这条指令的下一行地址
  
  要跳转的地方 = E8当前地址 + 5 + X                  此处 E8当前地址+5 = 下一行指令地址
  X = 要跳转的地址 - （E8的地址 + 5）              

 实现步骤：
1、寻找OEP所对应的文件偏移位置
2、在文件中修改OEP的指向，指向我们的空白区
3、空白区添加我们的代码
4、跳回原OEP指向的地址

RVA与FOA相互转换：

1.RVA TO FOA

1.内存中的地址减去内存基址得到偏移，即RVA
2.循环遍历节表中各个节的信息，判断在那个节中，(需要满足：内存地址+节数据对齐前大小>image偏移>内存偏移
3.找出在那个节后，减去该节在内存中的偏移（VirtualAddress)得到在该节中的相对偏移
4.上一步得到的该节的相对内偏移+该节在文件中的偏移(PointToRawData),即FOV

2、OA TO RVA

1.文件中的地址减去文件基址，得到在文件中得到偏移，即FOV
2.循环遍历节表中各个节的信息，判断在那个节中。（文件对齐+文件偏移>file偏移>文件偏移）
3.找出哪一个节后，减去该节在内存中的偏移(virtualAddress)得到在该节中的相对地址
4、上一步的得到的该节的相对地址+该节在内存中的偏移(VirtualAddress），即得到RVA





新增节

1、判断是否有足够的空间，可以添加一个节表     一个节表占40字节

 	判断条件：
	 SizeofHeader - (DOS + 立即数据+PE标记+标准PE头+可选PE头+已存在的节表） >= 2个节表的大小

2、需要修改的数据

	1.添加一个新的节（可以copy一份）
	2.再新增节后面填充一个节的大小的00
	3.修改PE头中节的数量
	4.修改sizeOfImage的大小
	5.在原有数据的最后，新增一个节的数据（内存对齐后的整数倍）
	6.修正新增节表的属性

3、 在内存中添加新的节表时，需要注意：
    新增节表中的VirtualAddress（内存中的偏移）必须是最后一个节表中VirtualAddress+max(VirtualSize,SizeOfRawData)
    (注意： 不一定SizeOfRawData比VirtualSize大)
    新增节表中的PoinTtoRawData(文件中的偏移)是最后一个节表中的PoinTtoRawData+SizeOfRawData


扩大节：

1、拉伸到内存

2、分配一块新的空间：SizeOfImage + Ex

3、将最后一个节的SizeOfRawData和VirtualSize改成 N

  SizeOfRawData = VirtualSize = N
  N = (SizeOfRawData或者VirtualSize 内存对齐的值） + Ex

4、修改SizeOfImage大小

    SizeOfImage = SizeOfImage + Ex


合并节：

1、拉伸到内存

2、将第一个节的内存大小、文件大小改成一样

      MAX = SizeOfRawData > VirtualSize ? SizeOfRawData : VirtualSize
      SizeOfRawData = VirtuaSize = 
      最后一个节的VirtualAddress + Max - SizeOfHeaders 内存对齐后的大小

3、将第一个节的属性改为包含所有节的数据

4、修改节的数量为1





























