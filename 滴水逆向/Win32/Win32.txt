win32 API ：即存放在C：\Windows\system32 下面所有的DLL

非常重要的几个DLL：
	
	Kernel32.dll : 最核心的功能模块，比如管理内存、进程和线程相关的函数等、
	User32.dll ：是windows用户界面相关应用程序接口，如创建窗口和发送信息等
	GDI32.dll：全称Graphical Device Interface（图形设备接口),包含用于画图和显示文本的函数，比如要显示一个
		程序窗口，就调用了其中的函数来画这个窗口

Win32 宽字符和多字节字符

(1) 包含头文件 #include <locale.h>										
(2) setlocale(LC_ALL,""); //使用控制台默认的编码					

	1.字符类型                          2.字符串指针
	char      	      CHAR	          PSTR（LPSTR）指向多字节字符串

	wchar_t	      WCHAR        PWSTR(LPWSTR) 指向宽字符串     例：wchar_t x1[] = L"中国"  L：查询UNICODE
	
	  宏  TCHA       宏   PTSTR（LPTSTR) 例：TCHAR cht[] = TEXT("中国"); TEXT：根据环境会自己转换
    
C语言中的宽字符和多字符													
							
	char		wchar_t		//多字节字符类型   宽字符类型										
	printf		wprintf		//打印到控制台函数										
	strlen		wcslen		//获取长度										
	strcpy		wcscpy		//字符串复制										
	strcat		wcscat		//字符串拼接										
	strcmp		wcscmp		//字符串比较										
	strstr		wcsstr		//字符串查找	

打印
	Win32程序不像普通的控制台程序，他的打印信息不会出现dos窗口，可以使用OutputDebugStringF函数出现在
	输入窗口。对OtputDebugStringF做些改动，就可以使打印信息再debug版中调用，而不是出现再正式的release版本中

头文件中：
void __cdecl OutputDebugStringF(const char *format, ...);
#ifdef _DEBUG  
#define DbgPrintf   OutputDebugStringF  
#else  
#define DbgPrintf  
#endif

源文件中：
void __cdecl OutputDebugStringF(const char *format, ...)
{
va_list vlArgs;
char    *strBuffer = (char*)GlobalAlloc(GPTR, 4096);

    va_start(vlArgs, format);
_vsnprintf(strBuffer, 4096 - 1, format, vlArgs);
va_end(vlArgs);
strcat(strBuffer, "\n");
OutputDebugStringA(strBuffer);
GlobalFree(strBuffer);
return;
}		

错误处理

DWORD GetLastError（VOID）
GetLastError返回的值通过再API函数中调用SetLastError或SetLastErrorEx设置。函数并无必要设置上一次错误信息，
所以即使一次GetLastError调用返回值为零，也不能担保函数已成功执行。只有在函数调用返回一个错误结果时，这个
函数指出的错误结构才是有效的。通常只有在函数返回一个错误结果，而且已知函数会设置GetLastError变量的前提下，
才应该访问GetLastError；这时能保证获得有效的结果


时间、消息、消息处理函数

typedef struct tagMSG {			
  HWND   hwnd; 			
  UINT   message; 			
  WPARAM wParam; 			
  LPARAM lParam; 			
  DWORD  time; 			
  POINT  pt; 			
} MSG, *PMSG; 			

1、hwnd
表示消息所属的窗口

一个消息一般都是与某个窗口相关联的
Windows中 HWND类型的变量通常用来表示窗口

2、message

在Windows中，消息是一个数值来表示的
但是由于数值不便于记忆，所以Windows将消息对应的数值定义为 WM_XXX宏（WM == Windows Message）
鼠标左键按下 WM_LBUTTONDOWN   键盘按下 WM_KEYDOWN

3、wParam 和 lParam

32位消息的特定附加信息，具体表示什么处决于message

4、time

消息创建时的时间

5、pt
消息创建时的鼠标位置


一个完整的消息流程

	1、系统/用户触发的某个动作			//事件

	2、系统将这些信息存储到MSG结构体 		//消息

	3、系统将该信息存储到相关应用程序的消息队列中	//消息队列

	4、  MSG Msg；							
	while(GetMessage(&Msg,NULL,0,0))        		//从队列中获取消息	
	{		
		TranslateMessage(&Msg);                  		//翻译消息  	
		DispatchMessage(&Msg);			//分派消息    	
	}

	5、DispatchMessage将加工过的信息传递 给操作系统

	6、系统调用窗口过程函数

	7、LRESULT CALLBACK WindowProc(  		//窗口过程函数	
		IN  HWND hwnd,  			//窗口句柄				
		IN  UINT uMsg,  			//消息类型			
		IN  WPARAM wParam,  						
		IN  LPARAM lParam  						
	  );  						
--------------------------------------------------------------------------------------------------------------------------------							

1、Win32应用程序入口识别

[<&KERNEL32.GetModuleHandleA ]其实就是得到WinMain中的第一个参数句柄，也就是WinMain中由stdcall被压栈的第四
参数，压栈实例句柄的下一个call，应该就是我们的WinMain函数入口，我们在跟进去看看就能确定是不是我们真正WinMan函数入口

2、ESP寻址的特点

进入WinMain函数，开展操作并不是常见的EBP寻址(push ebp, move ebp, esp) ，而是sub esp，44这种
debug大多采用EBP+偏移开栈，release大多采用ESP - 偏移开栈
ESP开栈，每次push压栈，pop出栈都会引起esp的变化，需要重点注意

3、窗口回调函数的定位

    窗口回调函数在WinMain函数中出现就是在函数开头构造wndclass类中，wndclass中的第二个参数就是窗口回调函
数的指针	
    而wndclass类可以通过RegisterClass函数得到，RegisterClass的唯一参数就是wndclass类的指针
    得到wndclass类的指针，由此可得回调函数的地址

4、具体时间的处理的定位

    打个条件断点，因为接受所有的事件，不做条件断点，会涌来很多相应
    再去查看Windows定义的时间编号
--------------------------------------------------------------------------------------------------------------------------------

按钮总结：
	
  1.按钮是一种特殊的窗口，并不需要提供单独的窗口回调函数
  2.当按钮有事件产生时，会给父窗口消息处理程序发送一个WM_COMMAND消息

                  单机按钮                                        转换WM_COMMAND      
  按钮————————> 系统提供WinProc  ———————————> 父窗口的WinProc

















































