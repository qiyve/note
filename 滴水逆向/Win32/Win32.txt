win32 API ：即存放在C：\Windows\system32 下面所有的DLL

非常重要的几个DLL：
	
	Kernel32.dll : 最核心的功能模块，比如管理内存、进程和线程相关的函数等、
	User32.dll ：是windows用户界面相关应用程序接口，如创建窗口和发送信息等
	GDI32.dll：全称Graphical Device Interface（图形设备接口),包含用于画图和显示文本的函数，比如要显示一个
		程序窗口，就调用了其中的函数来画这个窗口

Win32 宽字符和多字节字符

(1) 包含头文件 #include <locale.h>										
(2) setlocale(LC_ALL,""); //使用控制台默认的编码					

	1.字符类型                          2.字符串指针
	char      	      CHAR	          PSTR（LPSTR）指向多字节字符串

	wchar_t	      WCHAR        PWSTR(LPWSTR) 指向宽字符串     例：wchar_t x1[] = L"中国"  L：查询UNICODE
	
	  宏  TCHA       宏   PTSTR（LPTSTR) 例：TCHAR cht[] = TEXT("中国"); TEXT：根据环境会自己转换
    
C语言中的宽字符和多字符													
							
	char		wchar_t		//多字节字符类型   宽字符类型										
	printf		wprintf		//打印到控制台函数										
	strlen		wcslen		//获取长度										
	strcpy		wcscpy		//字符串复制										
	strcat		wcscat		//字符串拼接										
	strcmp		wcscmp		//字符串比较										
	strstr		wcsstr		//字符串查找	

打印
	Win32程序不像普通的控制台程序，他的打印信息不会出现dos窗口，可以使用OutputDebugStringF函数出现在
	输入窗口。对OtputDebugStringF做些改动，就可以使打印信息再debug版中调用，而不是出现再正式的release版本中

头文件中：
void __cdecl OutputDebugStringF(const char *format, ...);
#ifdef _DEBUG  
#define DbgPrintf   OutputDebugStringF  
#else  
#define DbgPrintf  
#endif

源文件中：
void __cdecl OutputDebugStringF(const char *format, ...)
{
va_list vlArgs;
char    *strBuffer = (char*)GlobalAlloc(GPTR, 4096);

    va_start(vlArgs, format);
_vsnprintf(strBuffer, 4096 - 1, format, vlArgs);
va_end(vlArgs);
strcat(strBuffer, "\n");
OutputDebugStringA(strBuffer);
GlobalFree(strBuffer);
return;
}		

错误处理

DWORD GetLastError（VOID）
GetLastError返回的值通过再API函数中调用SetLastError或SetLastErrorEx设置。函数并无必要设置上一次错误信息，
所以即使一次GetLastError调用返回值为零，也不能担保函数已成功执行。只有在函数调用返回一个错误结果时，这个
函数指出的错误结构才是有效的。通常只有在函数返回一个错误结果，而且已知函数会设置GetLastError变量的前提下，
才应该访问GetLastError；这时能保证获得有效的结果


时间、消息、消息处理函数

typedef struct tagMSG {			
  HWND   hwnd; 			
  UINT   message; 			
  WPARAM wParam; 			
  LPARAM lParam; 			
  DWORD  time; 			
  POINT  pt; 			
} MSG, *PMSG; 			

1、hwnd
表示消息所属的窗口

一个消息一般都是与某个窗口相关联的
Windows中 HWND类型的变量通常用来表示窗口

2、message

在Windows中，消息是一个数值来表示的
但是由于数值不便于记忆，所以Windows将消息对应的数值定义为 WM_XXX宏（WM == Windows Message）
鼠标左键按下 WM_LBUTTONDOWN   键盘按下 WM_KEYDOWN

3、wParam 和 lParam

32位消息的特定附加信息，具体表示什么处决于message

4、time

消息创建时的时间

5、pt
消息创建时的鼠标位置


一个完整的消息流程

	1、系统/用户触发的某个动作			//事件

	2、系统将这些信息存储到MSG结构体 		//消息

	3、系统将该信息存储到相关应用程序的消息队列中	//消息队列

	4、  MSG Msg；							
	while(GetMessage(&Msg,NULL,0,0))        		//从队列中获取消息	
	{		
		TranslateMessage(&Msg);                  		//翻译消息  	
		DispatchMessage(&Msg);			//分派消息    	
	}

	5、DispatchMessage将加工过的信息传递 给操作系统

	6、系统调用窗口过程函数

	7、LRESULT CALLBACK WindowProc(  		//窗口过程函数	
		IN  HWND hwnd,  			//窗口句柄				
		IN  UINT uMsg,  			//消息类型			
		IN  WPARAM wParam,  						
		IN  LPARAM lParam  						
	  );  						
--------------------------------------------------------------------------------------------------------------------------------							

1、Win32应用程序入口识别

[<&KERNEL32.GetModuleHandleA ]其实就是得到WinMain中的第一个参数句柄，也就是WinMain中由stdcall被压栈的第四
参数，压栈实例句柄的下一个call，应该就是我们的WinMain函数入口，我们在跟进去看看就能确定是不是我们真正WinMan函数入口

2、ESP寻址的特点

进入WinMain函数，开展操作并不是常见的EBP寻址(push ebp, move ebp, esp) ，而是sub esp，44这种
debug大多采用EBP+偏移开栈，release大多采用ESP - 偏移开栈
ESP开栈，每次push压栈，pop出栈都会引起esp的变化，需要重点注意

3、窗口回调函数的定位

    窗口回调函数在WinMain函数中出现就是在函数开头构造wndclass类中，wndclass中的第二个参数就是窗口回调函
数的指针	
    而wndclass类可以通过RegisterClass函数得到，RegisterClass的唯一参数就是wndclass类的指针
    得到wndclass类的指针，由此可得回调函数的地址

4、具体时间的处理的定位

    打个条件断点，因为接受所有的事件，不做条件断点，会涌来很多相应
    再去查看Windows定义的时间编号
--------------------------------------------------------------------------------------------------------------------------------

按钮总结：
	
  1.按钮是一种特殊的窗口，并不需要提供单独的窗口回调函数
  2.当按钮有事件产生时，会给父窗口消息处理程序发送一个WM_COMMAND消息

                  单机按钮                                        转换WM_COMMAND      
  按钮————————> 系统提供WinProc  ———————————> 父窗口的WinProc

-------------------------------------------------------------------------------------------------------------------------------

资源文件、创建对话框
1、创建一个空的Win32应用程序
2、在vs种新增资源
创建成功后会新增两个文件：xxx.rc  和 resource.h
3、打开新创建的xxx.rc 文件，新增一个对话框，并在对话框新增2个按钮
4、打开resource.h文件，会发现编译器自动给生成了宏
5、通过DialogBox创建对话框
INT_PTR DialogBox(					
  HINSTANCE hInstance,  // handle to module					
  LPCTSTR lpTemplate,   // dialog box template					
  HWND hWndParent,      // handle to owner window					
  DLGPROC lpDialogFunc  // dialog box procedure					
);					
6、第一Dialog消息处理函数  处理过返回TRUE ， 未处理返回FALSE


资源表

typedef struct _IMAGE_RESOURCE_DIRECTORY {								
    DWORD   Characteristics;				//资源属性  保留 0		
    DWORD   TimeDateStamp;				//资源创建的时间		
    WORD    MajorVersion;				//资源版本号 未使用 0		
    WORD    MinorVersion;				//资源版本号 未使用 0		
    WORD    NumberOfNamedEntries;			//以名称命名的资源数量		
    WORD    NumberOfIdEntries;			//以ID命名的资源数量		
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];								
} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;								

数据目录项

typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {									
    union {					//目录项的名称、或者ID			
        struct {									
            DWORD NameOffset:31;										
            DWORD NameIsString:1;	//用于判断存储值的 低31 是名称或者ID								
        };									
        DWORD   Name;									
        WORD    Id;									
    };									
    union {									
        DWORD   OffsetToData;			//目录项指针			
        struct {									
            DWORD   OffsetToDirectory:31;									
            DWORD   DataIsDirectory:1;									
        };									
    };									
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;									

数据项

typedef struct _IMAGE_DATA_DIRECTORY {					
    DWORD   VirtualAddress;					
    DWORD   Size;					
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;					


IMAGE_RESOURCE_DIRECTOry_ENTRY

Name的含义：资源类型         第一层    	   第二层		第三层：
	     	             光标：1	   资源编号	代码页
		             位图：2
		             图标：3
		             菜单：4
		             对话框：5  
		             共16种预定义类型....

特别说明：
1、当最高位是1时，低31位时一个UNICODE指针，指向一个结构体：
typedef struct _IMAGE_RESOURCE_DIR_STRING_U {						
    WORD    Length;		//长度				
    WCHAR   NameString[ 1 ];	//字符串首地址				
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;

2、当最高位是0时，表示字段的值作为 ID使用
3、如何判断第一位的值？
pResourceEntry[i].Name & 0x80000000 == 0x80000000	
pResourceEntry[i].NameIsString == 1					

OffsetToData的含义

最高位如果为1，低31位 + 资源地址 == 下一层目录节点的起始位置
第一层、第二层全为1
最高位如果为0，指向 IMAGE_RESOURCE_DATA_ENTRY
第三次为0

-----------------------------------------------------------------------------------------------------------------------------

Windows通用控件，代码包含在Comctr132.dll

使用前：
#include<commctrl.h>
#pragma comment( lib, "comctl32.lib" )

特别说明：

通用控件在使用前，需要通过INITCOMMONCONTROLSEX进行初始化
是要在您的程序中的任意地方引用了该函数，会使得 WINDOWS的程序加载器PE Loader加载该库

INITCOMMONCONTROLSEX  icex；
icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
icex.dwICC = ICC_WIN95_CLASSES;
InitCommonControlsEx(&icex);


WM_NOTIFY的使用

该消息类型与WM_COMMAND类型相似，都是由子窗口向父窗口发送的消息
WM_NOTIFY可以包含比WM_COMMAND更丰富的信息
Windows通用组件中有很多消息，都是通过WM_NOTIFY来描述的


WM_NOTIFY消息中的参数如下：							
							
	wParam:控件ID						
							
	lParam:指向一个结构						
							
	typedef struct tagNMHDR { 						
	        HWND hwndFrom; //发送通知消息的控制窗口句柄						
	        UINT idFrom;   //发送通知消息的控制ID值						
	        UINT code;     //通知码，如LVM_SELCHANGED						
	    } NMHDR; 						
							
							
这个结构体能满足一般的要求，但能描述的信息还是有限的							
							
解决方案：对每种不同用途的通知消息都定义另一种结构来表示							
							
	typedef struct tagNMLVCACHEHINT {						
	    NMHDR   hdr;		//本质 就是继承				
	    int     iFrom;						
	    int     iTo;						
	} NMLVCACHEHINT, *PNMLVCACHEHINT;						
							
	typedef struct tagLVDISPINFO {						
	    NMHDR hdr;						
	    LVITEM item;						
	} NMLVDISPINFO, FAR *LPNMLVDISPINFO;						
							
	typedef struct _NMLVFINDITEM {						
	    NMHDR hdr;						
	    int iStart;						
	    LVFINDINFO lvfi;						
	} NMLVFINDITEM, *PNMLVFINDITEM;						

			










































